4a
huristic 
어떤 값보다 작은 h
G가 최적의 솔루션이라고 하면
내가 찾은게 G2라고 하면 얘를 먼저 찾을 수는 없을까?

g(x) : cost 최소비용 찾는다면
g(G1) < g(G2)
A*가 G2를 먼저 찾았다고 가정 f(G2) = g(G2) (h = 0)

f(G2) = g(G2) > g(G1)

G1에 반드시 거쳐가야하는 n이 큐 안에 있는가?

Q에 f값들이 정렬되어서 들어가있음

f(G1) >= f(n)

g + h 
h는 실제 값보다 작도록 되어있다. 즉, 추정치이다.

g(G2) = g(n) + g(n~G2)
f(n) = g(n) +h(n)
admissible , g(n~G2) >= h(n)
즉, 최적가기 바로 전의 중간노드는 이미 큐에 들어가있다.
결국 최적의 답을 찾을 수 있다.

이걸 증명하는 건 시험X

f의 값이 점점 늘어나는 방향으로 탐색을 한다.
ex) 420까지의 모든 길을 탐색 그 안에 있는 값들을

best - first search?

시간이 지수적으로 비례 h, 즉 차이(error)
모든 노드를 갖고있다.

실제값보다 작거나 같은 값중에 최댓값이 좋다.

8-puzzle
h1(n) = number of misplaced tiles
h2(n) = total Manhattan distance
h2가 더 크다 h1보다

relaxed version!
휴리스틱: 원래 문제를 완화해서 생각해봐라~~
A*: 시험에 나온다


내 플레이를 하면서 상대방을 막아야한다
Games
제로섬 게임에 유효한 것.
minimax
최대 - 최소 - 최대 - 최소 - ......
상대편이 최소가 되도록 할 것을 고려해서 해야한다는 것.

내가 3개중에 맥시마이즈하는 걸 찾을 거야.
근데 이건 상대편이 미니마이즈한 것의 결과에서 시작
recursive func.
이건 상대방을 부르는 코드

dfs: recursive or stack

가장 마지막, terminal일 경우 둘중에 작은 걸 고르는 느낌으로.
v는 로컬 값.
즉 minimax도 dfs이다.

상대방도 best play를 한다고 생각하고 하는것.

중간 값을 다 채워라 문제

b branch, m depth

α-β pruning
존 맥카시 이외에도 이전에 논의되어왔다. 
안봐도 되는~~
알파베타 사이에 있는 노드이면 살펴볼 필요가 있다.

3-12-8 있을때 3을 먼저본다면 3보다 작거나 같은 값만 찾을 것이다.
아예 내려가지도 않는다? 내려가서 작은지 확인하는게 아니라 더 큰 숫자라면 애초에
신경쓰지도 않는듯.

즉 그 사이 값이면 계속 확인

자식한테 자신이 갖고있던 알파베타값을 줌.


시험은 역사X 코드 X 알고리즘만 확실히 해라!
새로운 문제에 대한 표현법
늑대와 양 이런거처럼

v = -inf 니까
v = 6을 가지고 오면 [6, 무한]
				[6,무한]

             [-무한,6]		[6,무한]		[-무한,무한]

[6,무한][8,6][9,8]  [6,무한][-무,무][-무,무]  [-무한,무한][-무한,무한][-무한,무한]



				[6,무한]
				
             [-무한,6]		[6,4]		[6,3]
		6		4		3	
[6,무한][8,6][9,8]  [8,무한][6,8][-무,무]  [6,무한][6,무한][-무한,무한]
6	8	7		4  		3	


알파 베타 어떻게 변하는지나 그런거 그냥 알고리즘을 다 알아봐야~











