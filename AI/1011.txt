알고리즘을 잘 보아라. 책에 있는거
코드짜는건 안할거얌
한 두칸 빼고 집어넣기 정도
서치에서 순서가 어떻게 되는지,
그 값은 뭔지
이론 중요한건 낼 수 있다
새로운걸 봤을때 어떤 앍리즘을 써서 풀어낼 것인가
할 수 있다. 왜냐면~~ 이렇기 때문에

로컬서치 알고리즘
그림을 그려보면 돌멩이기를 지나는 화성탐사선
로컬 서치는 자기가 탐험하는 (solution) 주변에서 탐험을 하는 것.
그런데 bfs는 솔루션놔두고 경로를 여러개를 한번에 하니까.
dfs는 로컬 서치.

즉, 보고있던 해 주변을 보는 것. 

Hill-climbing   신경망, 레이어와 레이어 사이에 weight를 가장 최적으로만들어서
결과값이 잘 나오게 하는것. 미분하는것.

제일 큰 objective function, y 값을 찾고 싶다.
x값이 너무 많으니까 부분을 나누어서 한다.
기울기가 높은 쪽으로 가는것.

그러다 내 주위에 나보다 높은 값이 없다면 거기서 끝.
strategy가 있다. 나보다 같은애가 주변에 있을때는 주변에 몇걸음가보자는 등.
local maximum

가장 좋은 방법은 random restart hill climbing!

8퀸 프로블럼 n개의 퀸을 놓는법, 퀸끼리 서로 잡지 않는법.

objective function을 서로 잡는 pair의 수라고 하면
0이 될때까지 찾는것.


Simulated annealing

고온에서 달궜다가 ~~ optimal한 상태가 되려면~~ 
여기서 아이디어를 얻었따.
메타휴리스틱방법 힐 클라이밍처럼 높은 곳으로 가지만 로컬에 빠지지 않도록.
가끔씩 나쁜 솔루션을 허용한다.는 특징
처음에는 나쁜 해로 잘 갈 수 있다.
시간이 지나면 지날수록 그 확률이 낮춰진다.
1000번돌린다. 처음에는 나쁜해로도 잘 가지만 1000번째는 거의 나쁜해로 안간다
로컬에 빠질 수 있지만 T라고 하는 것이(온도) 이게 천천히 낮아진다면
글로벌 솔루션을 찾을 확률이 1에 가깝다.

schedule: 온도변화

T=0아니면 주변의 successor,  next

word segmentation example

01 : 0은 넘어가고 1에는 다음칸 띄어쓰기
컴퓨터가 seg2가 정답인지 모르는데 seg2를 만들어내도록.

objective function 
lexicon +1 (띄어쓰기), 해서 lexicon의 합

derivation: 단어수.
최종 값이 최소가 되도록

전체 길이가 temperature
hill climbing , SA 의 사이 코드이다.
여기서 나쁠때도 이 확률로 가게 해주면 완전한 SA

같은 단어가 많으면 좋다

Local beam search
원래는 초기값을 두고, 하나를 가지고 좋아질때까지 계속 하는것.
이거는 하나가 아니라 제일 좋은 k를 가지고 하는것.


Genetic algorithms 많이 쓴대


랜덤하게 만든 k를 population이라고 하고 random한 statefmf gene이라고 함.
유전자에서 고안을 했다고함,

유전자를 어떻게 만들 것인가
objective function을 어떻게 만들 것인가.

랜덤하게 k를 100개 1000개 만듬.
그중에 좋은거 두개를 선정, 조합함.
돌연변이를 만드는 확률 약 50프로정도? 꽤 높게.

fitness 공격하지 않는 pair의 개수

항상 제일 좋은애만 하는거 elite~ 그러나 확률로 하겠다하면
roulette wheel 가끔은 나쁜애들 뽑는거 SA랑 비슷하다

k개만큼 만들었을때 fitness의 총합을 분모로, 자신의 fitness를 분자로해서
확률을 정해서 roulette wheel

cross over는 부모를 조합해서 만드는것.

랜덤하게, 임의의 population있음. 어떤 fitnessFN을 사용할것인지 해도됨

randint를 써서 확률 정함.

리스트에서 그냥 = 하면 복사가 안된다?
그래서 리스트에서는 b= list(a) 또는 b= a[:]로 한다/

초기 시작을 여러개로 싲가한다. 그중에서 두개를 조합해서 자식을 만들고
다양하게 조합하고 좋은애가뽑힐 확률이 높을 정도로만 하고,
뮤테이션도 한다.

제네틱알고리즘 하나와 리프로듀스 하나, 랜덤셀렉트 하나

