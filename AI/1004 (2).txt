depth, Astar 과제로 나갈듯?
chapter 3b 9p 

이미 한 번 본 것은 expand하지 않는다.
explored를 set으로

Complete? 답이 있으면 찾느냐? Yes
Optimal한것도 맞다.

노드를 몇개 generate했는지에 따라 계산한다.

2^0 2^1 2^2 ..... 각 레벨에서의 노드개수

b:# of branch 
d:soultion의 depth
n : max depth
depth d에서 답을 찾았다. 그럼 b^d가 맞는데, 
그 밑에(다음번레벨) children을 미리 만든것.
근데 맨 끝애는 빼고 만들어서 -1해준다.
지금 이게 7p

depth가 짧은것 vs 비용이 짧은 것

어느 노드일지 모르기 때문에 다 가지고 있어야함. big O(b^(d+1))

2차원 리스트 만들어서 퍼즐

비용을 보고 가장 적은애부터 바꾸는 것.

뎁스는 자식을 먼저 보는 것. 스택으로 만든다.

저번에 만들었던 것에서 큐를 스택으로 바꾸어준다

자녀를 먼저보고 자녀가 끝나면 다른쪽 자녀를 본~~~

비용은 답이 아닌 곳의 자녀들을 다 뒤진 후에
답을 찾는것이 문제  

optimal이 아니다. time이 가장 크~
장점은 공간을 많이 차지하지 않을 수 있다.
내려가다가 답이 안나오면 삭제해도 되니까!!

depth의 리밋을 설정해둔다.
운좋게 빨리 나올수도 있고 운나쁘게 나올수도있고~
limit을 1,2,3,4, ... 하나씩 늘리는 iterative deepening search

이건 child를 만들자마자 골테스트 안하는 bfs보다 효율 좋다.

time의 계수는 b^n n번째에 몇번 생기는지


농부가 없으면 늑대가 염소를 염소는 배추를 먹는다

[농부,늑대,염소,양배추]

state대신에 list를 쓴다.

목표상태에서 그 전 상태를 프린트하면 된다.
방문한 녀석 또는 불가능한 녀석이면 expand해서는 안된다.
action이 없다!
True False면 not만 하면 되니까 편하다

[----------------------------------------------------]

그럴듯한 친구를 찾는것..!?
Best First search 는 별로 중요하지 않다
최단직선거리를 알고있을 때 arad에서 갈 수있는 세 도시의
각각 최단직선거리 부레스트까지를 비교해서 제일 가까운곳에간다
local minimum local minimum
이때까지 온 거리, 비용을 생각하지 않았기때문에 생기는 일.
그래서 그거까지 계산한게 A star

차일드를 생성하고 골인지 확인하면 잘못된 답이 나온다
즉 큐에 집어넣고나서 나중에 팝해서 테스트한다.

큐가 f값을 기준으로 정렬되어있다.
큐안에는 노드가 있고 노드에 f나 h등등
노드의 f값 기준으로 sort하라는 기준을세워줘야함.
f넣을때마다 계속 확인하면서 작은 동안 확인하다가
그 사이에 넣어주는식으로

아니면 그냥 f값을 비교해서 sort해라고 할 수도 있음.
이건 복잡도가 증가할 우려. 데이터 많을때 

즉 우리가 해야할 것은 sorted Queue by f (h+g)
repeated state check해주기



















